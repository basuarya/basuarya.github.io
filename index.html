<!DOCTYPE html>
<html lang="en">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<head>
		<title>Alternate Bootstrap Level</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>

		<meta charset="utf-8">
		<meta name="description" content=""/>
  		<link href="css/styles.css" rel="stylesheet">
  		<link href="css/gradients.css" rel="stylesheet">
  		
  

	</head>
	<body>


		<header>
      		<nav class="website-nav">
		        <ul class="container flex">
		          <li class="item flex-item"><a href="links.html">Links</a></li>
		        </ul>
      		</nav>
    	</header>

		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		
		
		<script>
			

			var scene, camera, renderer;
			var geometry, material, mesh, outlineMesh, outlineMaterial;

			var raycaster;

			var mouse;


			var backgroundMesh, backgroundScene, backgroundCamera, texture;

			var textureCube, textureEmissive;
		    

			init();
			animate();



			function init() {

				

				scene = new THREE.Scene();
				

				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();
				

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1000;

				
				textureCube = THREE.ImageUtils.loadTexture( 'https://basuarya.github.io/resources/AdobeStock_69069070.png');
				textureEmissive = THREE.ImageUtils.loadTexture( 'https://basuarya.github.io/resources/white_emission.jpg');

				// LIGHT
				scene.add( new THREE.AmbientLight( 0xf0f0f0 ) );
				//const light = new THREE.SpotLight( 0xffffff, 1.5 );
				//light.position.set( 0, 1500, 200 );
				//light.angle = Math.PI * 0.2;
				//light.castShadow = true;
				//light.shadow.camera.near = 200;
				//light.shadow.camera.far = 2000;
				//light.shadow.bias = - 0.000222;
				//light.shadow.mapSize.width = 1024;
				//light.shadow.mapSize.height = 1024;
				//scene.add( light );

				geometry = new THREE.BoxGeometry( 200, 200, 200 );
				material = new THREE.MeshStandardMaterial( { color: 0xffffff , alphaMap: textureCube, wireframe: true, emissiveMap: textureEmissive, emissiveIntensity: 0.1  } );

				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				outlineMaterial = new THREE.MeshBasicMaterial( { color: 0x999999, side: THREE.BackSide } );
				outlineMesh = new THREE.Mesh( geometry, outlineMaterial );
				
				
				outlineMesh.scale.multiplyScalar(1.05);
				
				scene.add( outlineMesh );

				
				renderer = new THREE.WebGLRenderer({alpha: true});
				
				
				renderer.setSize( window.innerWidth, window.innerHeight );

				// Load the background texture
		        // do not load the heavy texture
		        texture = THREE.ImageUtils.loadTexture( 'https://spatiotemporalbasu.com/resources/wireframe.png' );
		        backgroundMesh = new THREE.Mesh(
		            new THREE.PlaneGeometry(2, 2, 0),
		            new THREE.MeshBasicMaterial({
		                map: texture
		            }));

		        backgroundMesh .material.depthTest = false;
		        backgroundMesh .material.depthWrite = false;
		        

		        // Create your background scene
		        backgroundScene = new THREE.Scene();
		        backgroundCamera = new THREE.Camera();
		        backgroundScene .add(backgroundCamera );
		        backgroundScene .add(backgroundMesh );


				// Add OrbitControls so that we can pan around with the mouse.
      			controls = new THREE.OrbitControls(camera, renderer.domElement);
      			
			

				document.body.appendChild( renderer.domElement );




			}

			
			function onMouseMove( event ) {

				// calculate mouse position in normalized device coordinates
				// (-1 to +1) for both components

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}

			function animate() {

				requestAnimationFrame( animate );

				mesh.rotation.x += 0.01;
				mesh.rotation.y += 0.01;

				
				outlineMesh.rotation.x = mesh.rotation.x;
				outlineMesh.rotation.y = mesh.rotation.y;
				
				
				// update the picking ray with the camera and mouse position
				raycaster.setFromCamera( mouse, camera );

				// calculate objects intersecting the picking ray
				var intersects = raycaster.intersectObjects( scene.children );


				var firstIntersectedObject;

				if (intersects.length > 0) {
			       var firstIntersectedObject  = intersects[0];
			       // this will give you the first intersected Object if there are multiple.

			       //console.log(firstIntersectedObject);
			       if(firstIntersectedObject.distance <= 7) {
			       	window.open('https://basuarya.github.io/spline.html', '_self');	
			       }
			       

			    }


			    renderer.autoClear = false;
	            renderer.clear();
	            renderer.render(backgroundScene , backgroundCamera );
	            


				renderer.render( scene, camera );
				controls.update();


			}


			
			

			window.addEventListener( 'mousemove', onMouseMove, false );
		
			
			
		</script>

  		<script src="js/set-background.js"></script>
		
	</body>

</html>